## Цель практической работы
- Закрепить понятие функции как объекта высшего порядка, отработать умение использовать функцию в качестве аргумента.
- Закрепить понятие декоратора и отработать умение его создавать и применять, а также применять специальный декоратор `functools.wraps()` для беспроблемного получения информации о декларируемой функции.
## Что входит в задание
- Задача 1. Как дела?
- Задача 2. Замедление кода.
- Задача 3. Логирование.
- Задача 4. Дебаг.
- Задача 5. Счетчик.
## Задача 1. Как дела?
### Что нужно сделать
Ваня что-то совсем заскучал на работе и решил побаловаться с кодом проекта. Он написал надоедливый декоратор, который при вызове декорируемой функции спрашивает у пользователя «Как дела?», вне зависимости от ответа отвечает что-то вроде «А у меня не очень!» и только потом запускает саму функцию. Правда, после такой выходки его чуть не уволили с работы.

Реализуйте такой же декоратор и проверьте его работу на нескольких функциях.

Пример кода:
```python
@how_are_you
def test():
    print('<Тут что-то происходит...>')


test()
```

Результат:
```
Как дела? Хорошо.
А у меня не очень! Ладно, держи свою функцию.
<Тут что-то происходит...>
```

### Что оценивается
- Результат вычислений корректен.
- Формат вывода соответствует примеру.
- Переменные, функции и собственные методы классов имеют значащие имена (не `a`, `b`, `c`, `d`).
- Классы и методы/функции имеют прописанную документацию.
- Есть аннотация типов для методов/функций и их аргументов (кроме `args` и `kwargs`). Если функция/метод ничего не возвращает, то используется `None`.
- Во всех декораторах используется `functools.wraps`.

## Задача 2. Замедление кода
### Что нужно сделать
В программировании иногда возникает ситуация, когда работу функции нужно замедлить. Типичный пример — функция, которая постоянно проверяет, изменились ли данные на веб-странице или её код.

Реализуйте декоратор, который перед выполнением декорируемой функции ждёт несколько секунд.
### Что оценивается
- Результат вычислений корректен.
- Сообщения о процессе получения результата осмыслены и понятны для пользователя.
- Переменные, функции и собственные методы классов имеют значащие имена (не `a`, `b`, `c`, `d`).
- Классы и методы/функции имеют прописанную документацию.
- Есть аннотация типов для методов/функций и их аргументов (кроме `args` и `kwargs`). Если функция/метод ничего не возвращает, то используется `None`.
- Во всех декораторах используется `functools.wraps`.

## Задача 3. Логирование
### Что нужно сделать
Реализуйте декоратор `logging`, который будет отвечать за логирование функций. На экран выводится название функции и её документация. Если во время выполнения декорируемой функции возникла ошибка, то в файл `function_errors.log` записываются названия функции и ошибки. 

Также постарайтесь сделать так, чтобы программа не завершалась после обнаружения первой же ошибки, а обрабатывала все декорируемые функции и сразу записывала все ошибки в файл.

Дополнительно: запишите дату и время возникновения ошибки, используя модуль `datetime`.
### Что оценивается
- Результат вычислений корректен.
- Сообщения о процессе получения результата осмыслены и понятны для пользователя.
- Переменные, функции и собственные методы классов имеют значащие имена (не `a`, `b`, `c`, `d`).
- Классы и методы/функции имеют прописанную документацию.
- Есть аннотация типов для методов/функций и их аргументов (кроме `args` и `kwargs`). Если функция/метод ничего не возвращает, то используется `None`.
- Во всех декораторах используется `functools.wraps`.

## Задача 4. Дебаг
### Что нужно сделать
Напишите декоратор debug, который при каждом вызове декорируемой функции выводит её имя (вместе со всеми передаваемыми аргументами), а затем — какое значение она возвращает. После этого выводится результат её выполнения.

Пример декорируемой функции:
```python
def greeting(name, age=None):
    if age:
        return "Ого, {name}! Тебе уже {age} лет, ты быстро растёшь!".format(name=name, age=age)
    else:
        return "Привет, {name}!".format(name=name)
```

Основной код:
```python
greeting("Том")
greeting("Миша", age=100)
greeting(name="Катя", age=16)
```

Результат:
```
Вызывается greeting('Том')
'greeting' вернула значение 'Привет, Том!'
Привет, Том!

Вызывается greeting('Миша', age=100)
'greeting' вернула значение 'Ого, Миша! Тебе уже 100 лет, ты быстро растёшь!'
Ого, Миша! Тебе уже 100 лет, ты вырос!

Вызывается greeting(name='Катя', age=16)
'greeting' вернула значение 'Ого, Катя! Тебе уже 16 лет, ты быстро растёшь!'
Ого, Катя! Тебе уже 16 лет, ты быстро растешь!
```

**Совет:** попробуйте самостоятельно изучить функцию `repr`. Это поможет в решении задачи.
### Что оценивается
- Результат вычислений корректен.
- Формат вывода соответствует примеру.
- Переменные, функции и собственные методы классов имеют значащие имена (не `a`, `b`, `c`, `d`).
- Классы и методы/функции имеют прописанную документацию.
- Есть аннотация типов для методов/функций и их аргументов (кроме `args` и `kwargs`). Если функция/метод ничего не возвращает, то используется `None`.
- Во всех декораторах используется `functools.wraps`.

## Задача 5. Счётчик
### Что нужно сделать
Реализуйте декоратор `counter`, считающий и выводящий количество вызовов декорируемой функции.

Для решения задачи нельзя использовать операторы `global` и `nonlocal` (об этом мы ещё расскажем).
### Что оценивается
- Результат вычислений корректен.
- Переменные, функции и собственные методы классов имеют значащие имена (не `a`, `b`, `c`, `d`).
- Классы и методы/функции имеют прописанную документацию.
- Есть аннотация типов для методов/функций и их аргументов (кроме `args` и `kwargs`). Если функция/метод ничего не возвращает, то используется `None`.
- Во всех декораторах используется `functools.wraps`.


